<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">

        <link href="./style/main.css" rel="stylesheet">

        <script src="./node_modules/requirejs/require.js" data-main="src/config"></script>

        <script>
            var everythingLoaded = setInterval(function() {
                if (window.AddUiInteractionsV4) {
                    clearInterval(everythingLoaded);
                    window.AddUiInteractionsV4()
                }
            }, 10);
        </script>
    </head>
    <body>
        <div class="container">
            <h1 class="h1">A proof of work</h1>

            <p>There’s a clever way of avoiding these problems, using an idea known as <b>proof-of-work</b>.
            The idea is counterintuitive and involves a combination of two ideas:</p>
            <p>(1) to (artificially) make it computationally costly for network users to validate transactions.</p>
            <p>(2) to reward them for trying to help validate transactions. The reward is used so that people on the network
            will try to help validate transactions, even though that’s now been made a computationally costly process.</p>
            
            <p>The benefit of making it costly to validate transactions is that validation can no longer be influenced by the
            number of network identities someone controls, but only by the total computational power they can bring to bear
            on validation. As we’ll see, with some clever design we can make it so a cheater would need enormous computational
            resources to cheat, making it impractical.</p>

            <p>That’s the gist of proof-of-work. But to really understand proof-of-work, we need to go through the details.</p>

            <p>Suppose Alice broadcasts to the network the news that <i>“I, Alice, am giving Bob one potato-coin, with serial number 1234567”</i>.</p>

            <p>As other people on the network hear that message, each adds it to a queue of pending transactions that they’ve been
            told about, but which haven’t yet been approved by the network. For instance, another network user named Dylan might
            have the following queue of pending transactions:</p>

            <p><code>{ "from": "Bob", "to": "Alice", "amount": 1, "date": 1234567 }</code></p>

            <p><code>{ "from": "Charlie", "to": "Bob", "amount": 1, "date": 3456789 }</code></p>

            <p><code>{ "from": "Alice", "to": "Bob", "amount": 1, "date": 7890123 }</code></p>

            <p>Dylan checks his copy of the block chain, and can see that each transaction is valid. He would like to help out by
            broadcasting news of that validity to the entire network.</p>

            <p>However, before doing that, as part of the validation protocol Dylan is required to solve a hard computational
            puzzle – the proof-of-work. Without the solution to that puzzle, the rest of the network won’t accept his validation
            of the transaction.</p>

            <p>What puzzle does Dylan need to solve? To explain that, let <code>h</code> be a fixed hash function known by everyone
            in the network – it’s built into the protocol. Bitcoin uses the well-known <a href="https://en.wikipedia.org/wiki/SHA-2">SHA-256</a>
            hash function, but any cryptographically secure hash function will do.</p>
            
            <p>Let’s say Dylan’s queue of pending transactions is a label, <code>l</code>, just so it’s got a name we can refer to.
            Suppose Dylan appends a number <code>x</code> (called the nonce) to <code>l</code> and hashes the
            combination.</p>
<p><b>x = "0000000000":</b></p>
<p><code>
h("[{ \"from\": \"Bob\", \"to\": \"Alice\", \"amount\": 1, \"date\": 1234567 },
{ \"from\": \"Charlie\", \"to\": \"Bob\", \"amount\": 1, \"date\": 3456789 },
{ \"from\": \"Alice\", \"to\": \"Bob\", \"amount\": 1, \"date\": 7890123 }]0000000000")
</code></p>
<p><code>= fe25f7a881925510b9c96008a3efff6d79aeffc3302d6acb530a34ab75941da0</code></p>

            <p>The puzzle Dylan has to solve – the proof-of-work – is to find a nonce <code>x</code> such that when we append <code>x</code>
            to <code>l</code> and hash the combination the output hash begins with a long run of zeroes. The puzzle can be
            made more or less difficult by varying the number of zeroes required to solve the puzzle. A relatively simple
            proof-of-work puzzle might require just three or four zeroes at the start of the hash, while a more difficult
            proof-of-work puzzle might require a much longer run of zeros, say 15 consecutive zeroes.
            In either case, the above attempt to find a suitable nonce, with x = 0, is a failure, since the
            output doesn’t begin with any zeroes at all.</p>

<p><b>x = "0000000001":</b></p>
<p><code>
h("[{ \"from\": \"Bob\", \"to\": \"Alice\", \"amount\": 1, \"date\": 1234567 },
{ \"from\": \"Charlie\", \"to\": \"Bob\", \"amount\": 1, \"date\": 3456789 },
{ \"from\": \"Alice\", \"to\": \"Bob\", \"amount\": 1, \"date\": 7890123 }]0000000001")
</code></p>
<p><code>= f96c2321f421094c45adb81267fe22a2fddd6662ca73e01a115a12ace6d4ccc2</code></p>

            <p><code>x</code> = "0000000001" doesn't work either, we can keep trying different values for the nonce,
            <code>x</code> = 0000000002, 0000000003,...</p>
            
<p>Finally, at <b>x = 0000003869</b> we obtain:</p>
<p><code>
h("[{ \"from\": \"Bob\", \"to\": \"Alice\", \"amount\": 1, \"date\": 1234567 },
{ \"from\": \"Charlie\", \"to\": \"Bob\", \"amount\": 1, \"date\": 3456789 },
{ \"from\": \"Alice\", \"to\": \"Bob\", \"amount\": 1, \"date\": 7890123 }]0000003869")
</code></p>
<p><code>= 0006530f9b816d547dff0551b99231d1f98192a3f442a76d65d8949fb869ef16</code></p>

            <p>What makes this puzzle hard to solve is the fact that the output from a cryptographic hash function behaves
            like a random number: change the input even a tiny bit and the output from the hash function changes completely,
            in a way that’s hard to predict. So if we want the output hash value to begin with 10 zeroes, say, then Dylan will
            need, on average, to try <code>16^{10} ≈ 10^{12}</code> different values for x before he finds a suitable nonce. That’s a
            pretty challenging task, requiring lots of computational power.</p>

            <p>Obviously, it’s possible to make this puzzle more or less difficult to solve by requiring more or fewer zeroes in
            the output from the hash function. In fact, the Bitcoin protocol gets quite a fine level of control over the
            difficulty of the puzzle, by using a slight variation on the proof-of-work puzzle described above. Instead of
            requiring leading zeroes, the Bitcoin proof-of-work puzzle requires the hash of a block’s header to be lower than
            or equal to a number known as the <a href="https://en.bitcoin.it/wiki/Target">target</a>. This target is automatically
            adjusted to ensure that a Bitcoin block takes, on average, about ten minutes to validate.</p>

            <p><div class="alert alert-info" role="alert">In practice there is a sizeable randomness in how long it takes to validate a block – sometimes a new block is
            validated in just a minute or two, other times it may take 20 minutes or even longer. It’s straightforward to modify
            the Bitcoin protocol so that the time to validation is much more sharply peaked around ten minutes. Instead of solving a
            single puzzle, we can require that multiple puzzles be solved; with some careful design it is possible to considerably
            reduce the variance in the time to validate a block of transactions.</div></p>

            <p>The proof-of-work validation brings us two things. First it is now very costly for any malicious user to swarm the network
            with fake users, as it is now his computation power that determine his impact on the network not his number of puppet users.
            Second, this new validation only needs one user to validate the transaction, we don't need to know how many users there
            is on the network anymore.</p>

            <article class="card" id="transaction-block" style="display: none;">
                <div class="card-block">
                    <ol style="margin: 0;">
                        <li><b>Transaction message:</b>
                            <code class="transaction"></code>
                        </li>

                        <li><b>Alice will then sign the message with her private key:</b>
                            <code class="signed-message"></code>
                        </li>

                        <li><b>Bob can then verify that the message is from Alice by checking the signature, check that the hash is valid and that he
                        cannot be found in his local blockchain, he finds that is is:</b>
                            <code class="verify-message"></code>
                        </li>

                        <li><b>But Bob do not consider the transaction "verified" yet. He will broadcast this message to all users in his network
                        that will verify it and add it to there pending "unverified" transactions</b></li>

                        <li><b>When enough transaction will have been receive by mining-users, they will start brute-forcing
                        for a hash of a block of transaction including Alice one. This hash will have to start with three zeros.</b></li>

                        <li><b>As soon as one user will have found such hash of a block he will proudly broadcast it to the network.</b></li>

                        <li><b>Bob (and other users) will check for the hash and if it is a valid one they will add the block to their blockchain
                        considering it "verified"</b></li>

                        <li><b>Bob being aware of that can now give Alice the potato she bought him.</b>
                    </ol>
                </div>                
            </article>

            <button class="btn btn-primary btn-sm" onclick="window.aliceSend1CoinToBob()">Make Alice send one coin to Bob 😇</button><br><br>

            <h3>Mining</h3>

            <p>Once you have sent more than 10 transactions you can click on the button below to have Dylan start mining the transactions
            you sent. When Dylan will have figured out a hash starting with three "0" of the block of transactions we will broadcast this
            block of transaction on the network. All users will receive it and will then consider these transaction as "verified".</p>

            <p><button class="btn btn-primary btn-sm" onclick="window.makeDylanMine()">Make Dylan start mining 😇</button></p>

            <div class="row navigation">
                <div class="col-sm-12">
                    <a class="btn btn-success float-left" href="./crypto-currency-v3.html"><< prev</a>                    
                    <a class="btn btn-success float-right" href="./crypto-currency-v5.html">next >></a>
                </div>
            </div>
        </div>

        <div class="close-network">❌</div>
        <div class="network">
            <div id="Alice"></div>
            <div id="Bob"></div>
            <div id="Charlie"></div>
            <div id="Dylan"></div>
            <div id="BobPuppet1"></div>
            <div id="BobPuppet2"></div>
            <div id="BobPuppet3"></div>
            <div id="BobPuppet4"></div>
        </div>
    </body>
</html>
