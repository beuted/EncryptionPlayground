<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">

        <link href="./style/main.css" rel="stylesheet">

        <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>

        <!-- Scripts comming from https://github.com/kjur/jsrsasign -->
        <script src="./vendors/jsrsasign/jsrsasign-all-min.js" type="text/javascript"></script>

        <script src="./js/crypto-currency-v4.js" type="text/javascript"></script>
        <script src="./js/crypto-currency-common.js" type="text/javascript"></script>

        <script type="text/javascript">

        var network = new Network();
        var alice = new User('Alice', `-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQDRhGF7X4A0ZVlEg594WmODVVUIiiPQs04aLmvfg8SborHss5gQ
Xu0aIdUT6nb5rTh5hD2yfpF2WIW6M8z0WxRhwicgXwi80H1aLPf6lEPPLvN29EhQ
NjBpkFkAJUbS8uuhJEeKw0cE49g80eBBF4BCqSL6PFQbP9/rByxdxEoAIQIDAQAB
AoGAA9/q3Zk6ib2GFRpKDLO/O2KMnAfR+b4XJ6zMGeoZ7Lbpi3MW0Nawk9ckVaX0
ZVGqxbSIX5Cvp/yjHHpww+QbUFrw/gCjLiiYjM9E8C3uAF5AKJ0r4GBPl4u8K4bp
bXeSxSB60/wPQFiQAJVcA5xhZVzqNuF3EjuKdHsw+dk+dPECQQDubX/lVGFgD/xY
uchz56Yc7VHX+58BUkNSewSzwJRbcueqknXRWwj97SXqpnYfKqZq78dnEF10SWsr
/NMKi+7XAkEA4PVqDv/OZAbWr4syXZNv/Mpl4r5suzYMMUD9U8B2JIRnrhmGZPzL
x23N9J4hEJ+Xh8tSKVc80jOkrvGlSv+BxwJAaTOtjA3YTV+gU7Hdza53sCnSw/8F
YLrgc6NOJtYhX9xqdevbyn1lkU0zPr8mPYg/F84m6MXixm2iuSz8HZoyzwJARi2p
aYZ5/5B2lwroqnKdZBJMGKFpUDn7Mb5hiSgocxnvMkv6NjT66Xsi3iYakJII9q8C
Ma1qZvT/cigmdbAh7wJAQNXyoizuGEltiSaBXx4H29EdXNYWDJ9SS5f070BRbAIl
dqRh3rcNvpY6BKJqFapda1DjdcncZECMizT/GMrc1w==
-----END RSA PRIVATE KEY-----`, network);
        var bob = new User('Bob', `-----BEGIN RSA PRIVATE KEY-----
MIICWgIBAAKBgHJNuOcdqshauCKFhxYHUNGuIyv6H7OLtUV+Ew3ra75hWWW2fMNl
gHFwATEIg9xaDHaVmGXxdBmot78ZUeNpVYuymflwfBl06VUxSYpl7QfS5M4E9gOV
sERX/ytzRl3uuTprk/LvGwcejsVpHLlxBuVPMy6u2yPE0+X59ayLX26/AgMBAAEC
gYBI0esyklvzOJiGpbrh9dcvPll58uevYxohI6jP/WOu7iYd/pyNf2TM4CZiLqKT
B2tZQQTOLX1hu3MUc/UPhFPSybbBh4aXPYU7cBPmXz910m7PwrQZcFUETKV2Mkug
sLim1baAq++O6jUYM6RRnEcdtag3uIN/21VCevx9yTqYAQJBALSN6Nj7OFRcQfiw
ijakun2H7ldNKOXH3c8DgRTDgBrfJDmOZlcIZmQ6G10ZsROk5beRkVgHGX8G3Dia
nU2el4ECQQCiEOapzIZCLEpfG3Ay+X6FQfrkhkvrg9EECucx0GYQ6bAUgkwTiLn6
g70sKXT2E2fYvEQDB0v1t6pAHHcMWyY/AkBjmJAj+NgGuOlvPDrRj6aLjkrr/1Ub
A1gYVE+E256zs/kwgptzUN/iU6c6gOyL8H8C9ppdG3V1+5vI4Yj6AwyBAkBkCTSo
GOPCkt4xSJmADXroPGrmhnL0ZAAvk59To0RtKiIS9r6IzDuoA4tQaCKXBjFymfsN
N4LOoFkJi8h8KwM3AkBXjoieYoy6eNIKa6QRn+/6qRhO5kxdh+KFXp1svc+dg93f
/tSfi+i2Pn1Z/v7CSW9oFmFcQAwwamYlbGaBK87V
-----END RSA PRIVATE KEY-----`, network);
        var charlie = new User('Charlie', `-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgHNNh/YaZnvIr58+v1MagvNjOzEg18yLVAQeZWpnNzE0qxquB2w2
eM2Rk6V9fh4WS35fatAvPfVqF/y5oZGwQ3v2ebm/AXTzrI+XCxJDRiHqsuIFRl8Z
98f0zs/NNCHtCLGqdnu0zNdL4OyA+dCeexcch6TUQklkvJRuCTUJRt9TAgMBAAEC
gYByjMMXj9DjB1Ta+0autDcGwD3tJ/jcoEr+sIgGtrZRb0bSAbUkH9XSPN+XWN5z
26hyyy7d1yFR8G4WSQGoMJpJdJH3De4RrU7ZCyx8Ln1xgk1DwoJPvOmPNcUftR5f
p3+XuuH/w6CywOtUttNgIdQeR6sIUCvgyCDHHbF5S8iMSQJBAMHKkTs9GEzK3r1s
o7Wgl/Mk4sIiAxExkD3m27IVoCWDD2QZUwLCnbaQqHQNq5GtGRRxs3ciPu4P54XU
C4RuKD8CQQCYUOu0cW229v4HVCVKeN51vbLDxdch38k9TswrQ1p3EzQuQTdxAkr4
svQGSPvyChktlCrr7Qlv9OkmOAFFdSPtAkBzxkInouNOlXCmuC3Bx5Sf1SyHkGxG
rFahNLeR1+uaHYdnZN2762rvc9K/qp8SY9h050yxYss3zFakFD9hObJfAkEAlW31
/92z/GcOStRTjV9NKAfGJGioqVPqEtqGVP9L9jwB2ksjABx2vsyZuLzLZ+ZeUyfk
f/bZZlvIjDUvkhvc9QJATDAOITmhUk/1iADjP1vqdmfVXZRdxs/iJYChQIrck0fb
hNQeR4DcAUEsr+l+d1ihUflkp+EEyyNEnpgbY0dpsw==
-----END RSA PRIVATE KEY-----`, network);
        var dylan = new User('Dylan', `-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgHoAhy90y1pqYuD+4v8Tg2eggd+/bk75xI3ATSC9ogZikOKNq5u3
gI9vRaylJhrzqdpdTu5whBY1g2QoOIHcjPmqnsTmHhMU4fNAhvLW+ThfYrwgsYlQ
YgipJBfwoZm+xc54tZbRhg89s9TXJk3H/d55WPEWN8F6V3nQukwldeqvAgMBAAEC
gYAUkgY5IC4xXoKxgQhxDa84R73eJf7JXh+f7u6SOKcbAH+BU3W92aDZjl9nDqlw
Heljohvu5BXBUOCIgKeWbcNvDrNNHfgOjrUjzLJ86IVw4zt5GeV/9XhPoH3rpfG6
CMJ2FbqRGJYxcPks3FteqAGRPLmAUiHZh/PYlPniuANQ0QJBAPD+noxaKcjlgLX5
zq2ljkBF+XhP9N9xdD74R1aDbpv5J8WH/UJUUCyoKsG4Iv7m2F7oa2bq1zPoaTWc
03/95WUCQQCBmTQs4s3xCa/8KF9C5UMmYOlE7sP1T+lT8N+p+pV2j7OHv03GcSG7
lv9CC6LCyID5/PBbJwVitmh768LUruiDAkB2zN31zGC600A+9PWIrotQbe5L/AZ3
u+MVQ6lPIZ1+MDYF70LO1udrDD9/nblKtRvGtYZ0hqItyY1Ly5KLjurtAkAB32fc
mi5lpEExwJeXzN5KiK32PAkC23PArcNdnmxYeT0b4gzKqEnXfxgTKT3h2KnccuY6
Ovcd9QrPd5mqHxjnAkEAydMa7DM1rmj90T7dHpUbyNcqbDgOg5mojEOPgQX2DClc
xvM6Gba9b8Yz8rS08V0oPVLEUz4IwtX17Hv5y8IuPw==
-----END RSA PRIVATE KEY-----`, network);

        var signedMessage;
        $(document).ready(function() {
            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());            
        });

        aliceSend1CoinToBob = function() {
            var message = alice.GetMessage("Bob", 1, Date.now());
            signedMessage = alice.GetSignedMessageWithSerialNumber("Bob", 1, Date.now());
            var sanityCheckOk = alice.VerifySignedMessageAndAddToUnvalidatedTransactions(signedMessage);
            if (sanityCheckOk)
                alice.BroadcastSignedMessage(signedMessage);

            $('#transaction-block').css("display", "block");

            $('.transaction').text(JSON.stringify(message, undefined, 2));
            $('.signed-message').text(JSON.stringify(signedMessage, undefined, 2));
            $('.verify-message').text(sanityCheckOk);

            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());
        }

        makeDylanMine = function() {
            dylan.Mine();

            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());
        }
        </script>
    </head>
    <body>
        <div class="container">
            <h1 class="h1">A proof of work</h1>

            <p>There’s a clever way of avoiding these problems, using an idea known as <b>proof-of-work</b>.
            The idea is counterintuitive and involves a combination of two ideas:</p>
            <p>(1) to (artificially) make it computationally costly for network users to validate transactions.</p>
            <p>(2) to reward them for trying to help validate transactions. The reward is used so that people on the network
            will try to help validate transactions, even though that’s now been made a computationally costly process.</p>
            
            <p>The benefit of making it costly to validate transactions is that validation can no longer be influenced by the
            number of network identities someone controls, but only by the total computational power they can bring to bear
            on validation. As we’ll see, with some clever design we can make it so a cheater would need enormous computational
            resources to cheat, making it impractical.</p>

            <p>That’s the gist of proof-of-work. But to really understand proof-of-work, we need to go through the details.</p>

            <p>Suppose Alice broadcasts to the network the news that <i>“I, Alice, am giving Bob one potato-coin, with serial number 1234567”</i>.</p>

            <p>As other people on the network hear that message, each adds it to a queue of pending transactions that they’ve been
            told about, but which haven’t yet been approved by the network. For instance, another network user named Dylan might
            have the following queue of pending transactions:</p>

            <p><code>{ "from": "Bob", "to": "Alice", "amount": 1, "date": 1234567 }</code></p>

            <p><code>{ "from": "Charlie", "to": "Bob", "amount": 1, "date": 3456789 }</code></p>

            <p><code>{ "from": "Alice", "to": "Bob", "amount": 1, "date": 7890123 }</code></p>

            <p>Dylan checks his copy of the block chain, and can see that each transaction is valid. He would like to help out by
            broadcasting news of that validity to the entire network.</p>

            <p>However, before doing that, as part of the validation protocol Dylan is required to solve a hard computational
            puzzle – the proof-of-work. Without the solution to that puzzle, the rest of the network won’t accept his validation
            of the transaction.</p>

            <p>What puzzle does Dylan need to solve? To explain that, let <code>h</code> be a fixed hash function known by everyone
            in the network – it’s built into the protocol. Bitcoin uses the well-known <a href="https://en.wikipedia.org/wiki/SHA-2">SHA-256</a>
            hash function, but any cryptographically secure hash function will do.</p>
            
            <p>Let’s say Dylan’s queue of pending transactions is a label, <code>l</code>, just so it’s got a name we can refer to.
            Suppose Dylan appends a number <code>x</code> (called the nonce) to <code>l</code> and hashes the
            combination.</p>
<p><b>x = "0000000000":</b></p>
<p><code>
h("[{ \"from\": \"Bob\", \"to\": \"Alice\", \"amount\": 1, \"date\": 1234567 },
{ \"from\": \"Charlie\", \"to\": \"Bob\", \"amount\": 1, \"date\": 3456789 },
{ \"from\": \"Alice\", \"to\": \"Bob\", \"amount\": 1, \"date\": 7890123 }]0000000000")
</code></p>
<p><code>= fe25f7a881925510b9c96008a3efff6d79aeffc3302d6acb530a34ab75941da0</code></p>

            <p>The puzzle Dylan has to solve – the proof-of-work – is to find a nonce <code>x</code> such that when we append <code>x</code>
            to <code>l</code> and hash the combination the output hash begins with a long run of zeroes. The puzzle can be
            made more or less difficult by varying the number of zeroes required to solve the puzzle. A relatively simple
            proof-of-work puzzle might require just three or four zeroes at the start of the hash, while a more difficult
            proof-of-work puzzle might require a much longer run of zeros, say 15 consecutive zeroes.
            In either case, the above attempt to find a suitable nonce, with x = 0, is a failure, since the
            output doesn’t begin with any zeroes at all.</p>

<p><b>x = "0000000001":</b></p>
<p><code>
h("[{ \"from\": \"Bob\", \"to\": \"Alice\", \"amount\": 1, \"date\": 1234567 },
{ \"from\": \"Charlie\", \"to\": \"Bob\", \"amount\": 1, \"date\": 3456789 },
{ \"from\": \"Alice\", \"to\": \"Bob\", \"amount\": 1, \"date\": 7890123 }]0000000001")
</code></p>
<p><code>= f96c2321f421094c45adb81267fe22a2fddd6662ca73e01a115a12ace6d4ccc2</code></p>

            <p><code>x</code> = "0000000001" doesn't work either, we can keep trying different values for the nonce,
            <code>x</code> = 0000000002, 0000000003,...</p>
            
<p>Finally, at <b>x = 0000003869</b> we obtain:</p>
<p><code>
h("[{ \"from\": \"Bob\", \"to\": \"Alice\", \"amount\": 1, \"date\": 1234567 },
{ \"from\": \"Charlie\", \"to\": \"Bob\", \"amount\": 1, \"date\": 3456789 },
{ \"from\": \"Alice\", \"to\": \"Bob\", \"amount\": 1, \"date\": 7890123 }]0000003869")
</code></p>
<p><code>= 0006530f9b816d547dff0551b99231d1f98192a3f442a76d65d8949fb869ef16</code></p>

            <p>What makes this puzzle hard to solve is the fact that the output from a cryptographic hash function behaves
            like a random number: change the input even a tiny bit and the output from the hash function changes completely,
            in a way that’s hard to predict. So if we want the output hash value to begin with 10 zeroes, say, then Dylan will
            need, on average, to try <code>16^{10} ≈ 10^{12}</code> different values for x before he finds a suitable nonce. That’s a
            pretty challenging task, requiring lots of computational power.</p>

            <p>Obviously, it’s possible to make this puzzle more or less difficult to solve by requiring more or fewer zeroes in
            the output from the hash function. In fact, the Bitcoin protocol gets quite a fine level of control over the
            difficulty of the puzzle, by using a slight variation on the proof-of-work puzzle described above. Instead of
            requiring leading zeroes, the Bitcoin proof-of-work puzzle requires the hash of a block’s header to be lower than
            or equal to a number known as the <a href="https://en.bitcoin.it/wiki/Target">target</a>. This target is automatically
            adjusted to ensure that a Bitcoin block takes, on average, about ten minutes to validate.</p>

            <p><div class="alert alert-info" role="alert">In practice there is a sizeable randomness in how long it takes to validate a block – sometimes a new block is
            validated in just a minute or two, other times it may take 20 minutes or even longer. It’s straightforward to modify
            the Bitcoin protocol so that the time to validation is much more sharply peaked around ten minutes. Instead of solving a
            single puzzle, we can require that multiple puzzles be solved; with some careful design it is possible to considerably
            reduce the variance in the time to validate a block of transactions.</div></p>

            <p>The proof-of-work validation brings us two things. First it is now very costly for any malicious user to swarm the network
            with fake users, as it is now his computation power that determine his impact on the network not his number of puppet users.
            Second, this new validation only needs one user to validate the transaction, we don't need to know how many users there
            is on the network anymore.</p>

            <article class="card" id="transaction-block" style="display: none;">
                <div class="card-block">
                    <ol style="margin: 0;">
                        <li><b>Transaction message:</b>
                            <code class="transaction"></code>
                        </li>

                        <li><b>Alice will then sign the message with her private key:</b>
                            <code class="signed-message"></code>
                        </li>

                        <li><b>Bob can then verify that the message is from Alice by checking the signature, check that the hash is valid and that he
                        cannot be found in his local blockchain, he finds that is is:</b>
                            <code class="verify-message"></code>
                        </li>

                        <li><b>But Bob do not consider the transaction "verified" yet. He will broadcast this message to all users in his network
                        that will verify it and add it to there pending "unverified" transactions</b></li>

                        <li><b>When enough transaction will have been receive by mining-users, they will start brute-forcing
                        for a hash of a block of transaction including Alice one. This hash will have to start with three zeros.</b></li>

                        <li><b>As soon as one user will have found such hash of a block he will proudly broadcast it to the network.</b></li>

                        <li><b>Bob (and other users) will check for the hash and if it is a valid one they will add the block to their blockchain
                        considering it "verified"</b></li>

                        <li><b>Bob being aware of that can now give Alice the potato she bought him.</b>
                    </ol>
                </div>                
            </article>

            <button class="btn btn-primary btn-sm" onclick="aliceSend1CoinToBob()">Make Alice send one coin to Bob 😇</button><br><br>

            <h3>Mining</h3>

            <p>Once you have sent more than 10 transactions you can click on the button below to have Dylan start mining the transactions
            you sent. When Dylan will have figured out a hash starting with three "0" of the block of transactions we will broadcast this
            block of transaction on the network. All users will receive it and will then consider these transaction as "verified".</p>

            <p><button class="btn btn-primary btn-sm" onclick="makeDylanMine()">Make Dylan start mining 😇</button></p>

            <div class="row navigation">
                <div class="col-sm-12">
                    <a class="btn btn-success float-left" href="./crypto-currency-v3.html"><< prev</a>                    
                    <a class="btn btn-success float-right" href="./crypto-currency-v5.html">next >></a>
                </div>
            </div>
        </div>

        <div class="close-network">❌</div>
        <div class="network">
            <div id="Alice"></div>
            <div id="Bob"></div>
            <div id="Charlie"></div>
            <div id="Dylan"></div>
            <div id="BobPuppet1"></div>
            <div id="BobPuppet2"></div>
            <div id="BobPuppet3"></div>
            <div id="BobPuppet4"></div>
        </div>
    </body>
</html>
