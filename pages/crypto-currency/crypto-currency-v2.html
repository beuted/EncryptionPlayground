<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
        
        <link href="./style/main.css" rel="stylesheet">
        
        <script src="./node_modules/requirejs/require.js" data-main="src/config"></script>

        <script>
            var everythingLoaded = setInterval(function() {
                if (window.AddUiInteractionsV2) {
                    clearInterval(everythingLoaded);
                    window.AddUiInteractionsV2()
                }
            }, 10);
        </script>
    </head>
    <body>
        <div class="container">

            <h1 class="h1">Using serial numbers to make coins uniquely identifiable</h1>

            <p>What we‚Äôd like is a way of making potato-coins unique. They need a label or serial number. Alice would sign the message
            <i>‚ÄúI, Alice, am giving Bob one potato-coin, with serial number 8740348‚Äù</i>. Then, later, Alice could sign the message <i>‚ÄúI, Alice,
            am giving Bob one potato-coin, with serial number 8770431‚Äù</i>, and Bob (and everyone else) would know that a different potato-coin
            was being transferred.</p>

            <p>Something that will look like this: <code>{ "from": "Alice", "to": "Bob", "serialNumber": "8740348‚Äù" }</code></p>

            <p>To make this scheme work we need a trusted source of serial numbers for the potato-coins. <b>One way to create such a source is
            to introduce a bank</b>. This bank would provide serial numbers for potato-coins, keep track of who has which potato-coins, and verify
            that transactions really are legitimate,</p>

            <p>In more detail, let‚Äôs suppose Alice goes into the bank, and says <i>‚ÄúI want to withdraw one potato-coin from my account‚Äù</i>. The
            bank reduces her account balance by one potato-coin, and assigns her a new, never-before used serial number, let‚Äôs say 1234567.
            Then, when Alice wants to transfer her potato-coin to Bob, she signs the message <i>‚ÄúI, Alice, am giving Bob one potato-coin, with serial
            number 1234567‚Äù</i>. But Bob doesn‚Äôt just accept the potato-coin. Instead, he contacts the bank, and verifies that: (a) the potato-coin
            with that serial number belongs to Alice; and (b) Alice hasn‚Äôt already spent the potato-coin. If both those things are true,
            then Bob tells the bank he wants to accept the potato-coin, and the bank updates their records to show that the potato-coin with that
            serial number is now in Bob‚Äôs possession, and no longer belongs to Alice.</p>
            <br>

            <h2 class="h2">Making everyone collectively the bank</h2>

            <p>This last solution looks pretty promising. However, it turns out that we can do something much more ambitious. We can eliminate
            the bank entirely from the protocol. This changes the nature of the currency considerably. It means that there is no longer
            any single organization in charge of the currency. And when you think about the enormous power a central bank has ‚Äì control
            over the money supply ‚Äì that‚Äôs a pretty huge change.</p>

            <p>The idea is to make it so everyone (collectively) is the bank. In particular, we‚Äôll assume that everyone using potato-coin keeps
            a complete record of which potato-coins belong to which person. You can think of this as a shared public ledger showing all
            potato-coin transactions. We‚Äôll call this ledger <b>the block chain</b>.</p>

            <p>Now, suppose Alice wants to transfer an potato-coin to Bob. She signs the message <i>‚ÄúI, Alice, am giving Bob one potato-coin, with
            serial number 1234567‚Äù</i>, and gives the signed message to Bob. Bob can use his copy of the block chain to check that, indeed,
            the potato-coin is Alice‚Äôs to give. If that checks out then he broadcasts both Alice‚Äôs message and his acceptance of the transaction
            to the entire network, and everyone updates their copy of the block chain.</p>

            <h2 class="h2">Where do serial number come from?</h2>

            <p>A simple idea to get this serial number would be to <b>use a hash of the message with its date</b>, so our previous messages would look 
            like this:</p>
    
            <article class="card" id="transaction-block" style="display: none;">
                <div class="card-block">
                    <ol style="margin: 0;">
                        <li><b>Transaction message:</b>
                            <code class="transaction"></code>
                        </li>

                        <li><b>Alice will then sign the message with her private key:</b>
                            <code class="signed-message"></code>
                        </li>

                        <li><b>Bob can then verify that the message is from Alice by checking the signature, that the hash is valid and that he
                        cannot be found in his local blockchain twice, he finds that it is:</b>
                            <code class="verify-message"></code>
                        </li>

                        <li><b>Bob will broadcast this message to all users, proving that he now owns +1 coin and Alice -1</b>

                        <li><b>Bob can now give Alice the potato she bought him. He can prove that Alice sent him a coin since he have a message signed with her private key</b>
                    </ol>
                </div>
            </article>

            <p><button class="btn btn-primary btn-sm" onclick="window.aliceSend1CoinToBob()">Make Alice send one coin to Bob üòá</button></p>            

            <p>As the transaction have been signed with Alice private key we can know for sure that Alice is okay with the transaction and since
            the hash parameter match the hash of the message and is unique on the network we can now for sure that <b>it have not been "replayed"</b></p>

            <h3>Simple double emission?</h3>
            <p><b>Previous signed transaction message:</b><code class="signed-message"></code></p>

            <p>This time Bob :</p>
            <ol>
                <li><b>cannot replay the message 10 times</b> because they will have the same hash:
                <button class="btn btn-primary btn-sm" onclick="window.broadcastSameMessage()">Try broadcasting the same transaction message üëø</button><br>
                </li>
                <li>and he <b>cannot change the message to change the hash</b> because the message will not be signed correctly anymore.
                <button class="btn btn-primary btn-sm" onclick="window.broadcastDifferentMessages()">Just change the date of the message to change its hash
                (with the same signature) üëø</button></li>
            </ol>

            <div class="alert alert-danger" role="alert">This implementation can still be abuse!</div>

            <h3>Timing attack</h3>
            <p>Great, having these hashes as serial numbers we can avoid simple double spending, but we are still weak against
            <i>"timing attacks"</i>, where malicious people spends money they don't have.</p>
            <p>Let's consider that Bob send <b>X coins</b> to Alice, (X being all the coins he has) and <b>at the exact same time</b>,
            send X coins to Charlie.</p>
            <p>What will happen is that Alice will update her local blockchain with the transaction where Bob gives her all his coins and
            Charlie will update his local blockchain with a transaction where bob gives him all his coins, and both will give bob X potatoes
            even tho' only one out of Alice and Charlie have been paid.</p>
            <p><button class="btn btn-primary btn-sm" onclick="window.broadcastSimultaneousMessages()">Simultaneously send two messages giving all Bob's money to Alice and Charlie üòà</button></p>
            <p>In order to avoid that we need a way to choose and validate a common version of the blockchain for all users. It means
            that we need to be able to choose if Bob have given all his coins to Alice or to Charlie.</p>
         
            <div class="row navigation">
                <div class="col-sm-12">
                    <a class="btn btn-success float-left" href="./crypto-currency-v1.html"><< prev</a>                    
                    <a class="btn btn-success float-right" href="./crypto-currency-v3.html">next >></a>
                </div>
            </div>
        </div>

        <div class="close-network">‚ùå</div>
        <div class="network">
            <div id="Alice"></div>
            <div id="Bob"></div>
            <div id="Charlie"></div>
        </div>
            
    </body>
</html>
