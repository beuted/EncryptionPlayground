<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">

        <link href="../style/main.css" rel="stylesheet">

        <script src="../vendors/jQuery-2.2.3.min.js" type="text/javascript"></script>

        <!-- Scripts comming from https://github.com/kjur/jsrsasign -->
        <script src="../vendors/jsrsasign/jsrsasign-all-min.js" type="text/javascript"></script>


        <script src="../crypto-currency-v3.js" type="text/javascript"></script>
        <script type="text/javascript">

        var network = new Network();
        var alice = new User('Alice', `-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQDRhGF7X4A0ZVlEg594WmODVVUIiiPQs04aLmvfg8SborHss5gQ
Xu0aIdUT6nb5rTh5hD2yfpF2WIW6M8z0WxRhwicgXwi80H1aLPf6lEPPLvN29EhQ
NjBpkFkAJUbS8uuhJEeKw0cE49g80eBBF4BCqSL6PFQbP9/rByxdxEoAIQIDAQAB
AoGAA9/q3Zk6ib2GFRpKDLO/O2KMnAfR+b4XJ6zMGeoZ7Lbpi3MW0Nawk9ckVaX0
ZVGqxbSIX5Cvp/yjHHpww+QbUFrw/gCjLiiYjM9E8C3uAF5AKJ0r4GBPl4u8K4bp
bXeSxSB60/wPQFiQAJVcA5xhZVzqNuF3EjuKdHsw+dk+dPECQQDubX/lVGFgD/xY
uchz56Yc7VHX+58BUkNSewSzwJRbcueqknXRWwj97SXqpnYfKqZq78dnEF10SWsr
/NMKi+7XAkEA4PVqDv/OZAbWr4syXZNv/Mpl4r5suzYMMUD9U8B2JIRnrhmGZPzL
x23N9J4hEJ+Xh8tSKVc80jOkrvGlSv+BxwJAaTOtjA3YTV+gU7Hdza53sCnSw/8F
YLrgc6NOJtYhX9xqdevbyn1lkU0zPr8mPYg/F84m6MXixm2iuSz8HZoyzwJARi2p
aYZ5/5B2lwroqnKdZBJMGKFpUDn7Mb5hiSgocxnvMkv6NjT66Xsi3iYakJII9q8C
Ma1qZvT/cigmdbAh7wJAQNXyoizuGEltiSaBXx4H29EdXNYWDJ9SS5f070BRbAIl
dqRh3rcNvpY6BKJqFapda1DjdcncZECMizT/GMrc1w==
-----END RSA PRIVATE KEY-----`, network);
        var bob = new User('Bob', `-----BEGIN RSA PRIVATE KEY-----
MIICWgIBAAKBgHJNuOcdqshauCKFhxYHUNGuIyv6H7OLtUV+Ew3ra75hWWW2fMNl
gHFwATEIg9xaDHaVmGXxdBmot78ZUeNpVYuymflwfBl06VUxSYpl7QfS5M4E9gOV
sERX/ytzRl3uuTprk/LvGwcejsVpHLlxBuVPMy6u2yPE0+X59ayLX26/AgMBAAEC
gYBI0esyklvzOJiGpbrh9dcvPll58uevYxohI6jP/WOu7iYd/pyNf2TM4CZiLqKT
B2tZQQTOLX1hu3MUc/UPhFPSybbBh4aXPYU7cBPmXz910m7PwrQZcFUETKV2Mkug
sLim1baAq++O6jUYM6RRnEcdtag3uIN/21VCevx9yTqYAQJBALSN6Nj7OFRcQfiw
ijakun2H7ldNKOXH3c8DgRTDgBrfJDmOZlcIZmQ6G10ZsROk5beRkVgHGX8G3Dia
nU2el4ECQQCiEOapzIZCLEpfG3Ay+X6FQfrkhkvrg9EECucx0GYQ6bAUgkwTiLn6
g70sKXT2E2fYvEQDB0v1t6pAHHcMWyY/AkBjmJAj+NgGuOlvPDrRj6aLjkrr/1Ub
A1gYVE+E256zs/kwgptzUN/iU6c6gOyL8H8C9ppdG3V1+5vI4Yj6AwyBAkBkCTSo
GOPCkt4xSJmADXroPGrmhnL0ZAAvk59To0RtKiIS9r6IzDuoA4tQaCKXBjFymfsN
N4LOoFkJi8h8KwM3AkBXjoieYoy6eNIKa6QRn+/6qRhO5kxdh+KFXp1svc+dg93f
/tSfi+i2Pn1Z/v7CSW9oFmFcQAwwamYlbGaBK87V
-----END RSA PRIVATE KEY-----`, network, );
        var charlie = new User('Charlie', `-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgHNNh/YaZnvIr58+v1MagvNjOzEg18yLVAQeZWpnNzE0qxquB2w2
eM2Rk6V9fh4WS35fatAvPfVqF/y5oZGwQ3v2ebm/AXTzrI+XCxJDRiHqsuIFRl8Z
98f0zs/NNCHtCLGqdnu0zNdL4OyA+dCeexcch6TUQklkvJRuCTUJRt9TAgMBAAEC
gYByjMMXj9DjB1Ta+0autDcGwD3tJ/jcoEr+sIgGtrZRb0bSAbUkH9XSPN+XWN5z
26hyyy7d1yFR8G4WSQGoMJpJdJH3De4RrU7ZCyx8Ln1xgk1DwoJPvOmPNcUftR5f
p3+XuuH/w6CywOtUttNgIdQeR6sIUCvgyCDHHbF5S8iMSQJBAMHKkTs9GEzK3r1s
o7Wgl/Mk4sIiAxExkD3m27IVoCWDD2QZUwLCnbaQqHQNq5GtGRRxs3ciPu4P54XU
C4RuKD8CQQCYUOu0cW229v4HVCVKeN51vbLDxdch38k9TswrQ1p3EzQuQTdxAkr4
svQGSPvyChktlCrr7Qlv9OkmOAFFdSPtAkBzxkInouNOlXCmuC3Bx5Sf1SyHkGxG
rFahNLeR1+uaHYdnZN2762rvc9K/qp8SY9h050yxYss3zFakFD9hObJfAkEAlW31
/92z/GcOStRTjV9NKAfGJGioqVPqEtqGVP9L9jwB2ksjABx2vsyZuLzLZ+ZeUyfk
f/bZZlvIjDUvkhvc9QJATDAOITmhUk/1iADjP1vqdmfVXZRdxs/iJYChQIrck0fb
hNQeR4DcAUEsr+l+d1ihUflkp+EEyyNEnpgbY0dpsw==
-----END RSA PRIVATE KEY-----`, network);
        var dylan = new User('Dylan', `-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgHoAhy90y1pqYuD+4v8Tg2eggd+/bk75xI3ATSC9ogZikOKNq5u3
gI9vRaylJhrzqdpdTu5whBY1g2QoOIHcjPmqnsTmHhMU4fNAhvLW+ThfYrwgsYlQ
YgipJBfwoZm+xc54tZbRhg89s9TXJk3H/d55WPEWN8F6V3nQukwldeqvAgMBAAEC
gYAUkgY5IC4xXoKxgQhxDa84R73eJf7JXh+f7u6SOKcbAH+BU3W92aDZjl9nDqlw
Heljohvu5BXBUOCIgKeWbcNvDrNNHfgOjrUjzLJ86IVw4zt5GeV/9XhPoH3rpfG6
CMJ2FbqRGJYxcPks3FteqAGRPLmAUiHZh/PYlPniuANQ0QJBAPD+noxaKcjlgLX5
zq2ljkBF+XhP9N9xdD74R1aDbpv5J8WH/UJUUCyoKsG4Iv7m2F7oa2bq1zPoaTWc
03/95WUCQQCBmTQs4s3xCa/8KF9C5UMmYOlE7sP1T+lT8N+p+pV2j7OHv03GcSG7
lv9CC6LCyID5/PBbJwVitmh768LUruiDAkB2zN31zGC600A+9PWIrotQbe5L/AZ3
u+MVQ6lPIZ1+MDYF70LO1udrDD9/nblKtRvGtYZ0hqItyY1Ly5KLjurtAkAB32fc
mi5lpEExwJeXzN5KiK32PAkC23PArcNdnmxYeT0b4gzKqEnXfxgTKT3h2KnccuY6
Ovcd9QrPd5mqHxjnAkEAydMa7DM1rmj90T7dHpUbyNcqbDgOg5mojEOPgQX2DClc
xvM6Gba9b8Yz8rS08V0oPVLEUz4IwtX17Hv5y8IuPw==
-----END RSA PRIVATE KEY-----`, network);

        var signedMessage;
        $(document).ready(function() {
            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());            
        });

        aliceSend1CoinToBob = function() {
            var message = alice.GetMessage("Bob", 1);
            signedMessage = alice.GetSignedMessageWithSerialNumber("Bob", 1, Date.now());
            var sanityCheckOk = alice.VerifySignedMessageAndAddToBlockChain(signedMessage);
            if (sanityCheckOk)
                alice.BroadcastSignedMessage(signedMessage);

            $('.transaction').text(JSON.stringify(message, undefined, 2));
            $('.signed-message').text(JSON.stringify(signedMessage, undefined, 2));
            $('.verify-message').text(sanityCheckOk);
            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());
        }

        broadcastSameMessage = function() {
            if (!signedMessage) {
                alert('First send a legit message to be able to replay it');
                return;
            }

            bob.BroadcastSignedMessage(signedMessage);
            
            // Refresh UI
            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());
        }

        broadcastDifferentMessages = function() {
            if (!signedMessage) {
                alert('First send a legit message to be able to replay it with a different date');
                return;
            }

            let modifiedMessage = Object.assign({}, signedMessage);
            modifiedMessage.message.date = Date.now();

            var md = new KJUR.crypto.MessageDigest({ alg: "sha256", prov: "cryptojs" });
            md.updateString(JSON.stringify(modifiedMessage));

            modifiedMessage.hash = md.digest();
            bob.BroadcastSignedMessage(modifiedMessage);
            
            // Refresh UI
            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());
        }

        broadcastSimultaneousMessages = function() {
            bob.ComputeMoneyForKnownUsers(); // Update bob exact amount of money based on his local blockchain
            signedMessage1 = bob.GetSignedMessageWithSerialNumber("Alice", bob.money, Date.now());
            signedMessage2 = bob.GetSignedMessageWithSerialNumber("Charlie", bob.money, Date.now());

            bob.BroadcastToSpecificUser("Alice", signedMessage1);
            bob.BroadcastToSpecificUser("Charlie", signedMessage2);

            // Bob only add Alice transaction to his local blockchain
            bob.VerifySignedMessageAndAddToBlockChain(signedMessage1);

            $('#Alice').replaceWith(alice.GetMarkup());
            $('#Bob').replaceWith(bob.GetMarkup());
            $('#Charlie').replaceWith(charlie.GetMarkup());
            $('#Dylan').replaceWith(dylan.GetMarkup());
        }

        </script>
    </head>
    <body>
        <div class="container">
            <h1 class="h1">Agreement on the state of the blockchain</h1>

            <p>How can we address the problem of double spending? The obvious solution is that when Bob sends
            Alice a Crypto-Coin, Alice shouldn‚Äôt try to verify the transaction alone. Rather, she should broadcast the
            possible transaction to the entire network of Crypto-coins users, and ask them to help determine whether
            the transaction is legitimate. If they collectively decide that the transaction is okay, then Alice can
            accept the Crypto-Coin, and everyone will update their block chain. This type of protocol can help prevent
            timing attack, since if Bob tries to spend his Crypto-Coin with both Alice and Charlie, other people on
            the network will notice, and network users will tell both Alice and Charlie that there is a problem with
            the transaction, and the transaction shouldn‚Äôt go through.</p>

            <p>In more detail, let‚Äôs suppose Bob wants to give Alice a Crypto-Coin. As before, he signs the message
            ‚ÄúI, Bob, am giving Alice one Crypto-Coin, with serial number 1234567‚Äù, and gives the signed message to Alice.
            Also as before, Alice does a sanity check, using his copy of the block chain to check that, indeed, the coin
            currently belongs to Alice. But at that point the protocol is modified. Alice doesn‚Äôt just go ahead and accept
            the transaction. Instead, she broadcasts Bob‚Äôs message to the entire network. Other members of the network
            check to see whether Bob owns that Crypto-Coin. If so, they broadcast the message ‚ÄúYes, Bob owns enough Crypto-Coin for
            the transaction 1234567, it can now be transferred to Alice.‚Äù Once enough people have broadcast that message,
            everyone updates their block chain to show that Crypto-Coin now belongs to Bob through the transaction 1234567‚Äù.</p>

            <p>This protocol has many imprecise elements at present. For instance, what does it mean to say ‚Äúonce enough people
            have broadcast that message‚Äù? What exactly does ‚Äúenough‚Äù mean here? It can‚Äôt mean everyone in the network, since
            we don‚Äôt a priori know who is on the Crypto-Coin network. For the same reason, it can‚Äôt mean some fixed fraction of
            users in the network. We won‚Äôt try to make these ideas precise right now. Instead, in the next section I‚Äôll point
            out a serious problem with the approach as described. Fixing that problem will at the same time have the pleasant
            side effect of making the ideas above much more precise.</p>

            <!--<h2>A proof of work</h2>

            <p>Suppose Alice wants to double spend in the network-based protocol I just described. She could do this by taking
            over the Crypto-coin network. Let‚Äôs suppose she uses an automated system to set up a large number of separate identities,
            let‚Äôs say a billion, on the Crypto-coin network. As before, she tries to double spend the same Crypto-coin with both Bob
            and Charlie. But when Bob and Charlie ask the network to validate their respective transactions, Alice‚Äôs sock puppet
            identities swamp the network, announcing to Bob that they‚Äôve validated his transaction, and to Charlie that they‚Äôve
            validated his transaction, possibly fooling one or both into accepting the transaction.</p>-->

            <div class="alert alert-success" role="alert">We are reaching here the issue that have stayed unsolved for about 30 years until somebody under the nickname of
            Satoshi Nakamoto published <a href = "https://bitcoin.org/bitcoin.pdf">a paper on the subject</a> in 2008 that will
            solve the issue of removing the "trusted 3rd party".</div>

            <p>Let's start with a simple idea, let's add a layer of verification to the system. Once Alice receive a coin from Bob
            She will first do all the checks on the hash, signature and amount of coins Bob owns we previously discussed.
            Alice will add the transaction in her blockchain but will not consider yet that it is valid.
            Alice will then ask all the network to validate that this translation legit or not, when Alice will receive let's say
            <b>50% of users in the network</b> responses saying that the transaction is correct. She will consider the transaction valid.</p>
    
            <button class="btn btn-primary" onclick="aliceSend1CoinToBob()">Make Alice send one coin to Bob üòá</button>

            <article class="card">
                <div class="card-block">
                    <ol style="margin: 0;">
                        <li><b>Transaction message:</b>
                            <code class="transaction"></code>
                        </li>

                        <li><b>Alice will then sign the message with her private key:</b>
                            <code class="signed-message"></code>
                        </li>

                        <li><b>Bob can then verify that the message is from Alice by checking the signature, check that the hash is valid and that he
                        cannot be found in his local blockchain, he finds that is is:</b>
                            <code class="verify-message"></code>
                        </li>

                        <li><b>Bob will broadcast this message to all users proving that he now owns +1 coin and Alice -1</b>

                        <li><b>Bob can now give Alice the potato she bought him. He can prove that Alice sent him a coin since he have a message signed with her private key</b>
                    </ol>
                </div>
            </article>

            <p>As the transaction have been signed with Alice private key we can know for sure that Alice is okay with the transaction and since
            the hash parameter match the hash of the message and is unique on the network we can now for sure that it have not been "replayed":
            If this encrypted transaction is broadcasted on the network everybody will be aware that Bob now have +1 coin and Alice -1 coin.</p>

            <h3 class="h3">State of the network</h3>
            <div class="row">
                <div id="Alice"></div>
                <div id="Bob"></div>
                <div id="Charlie"></div>
                <div id="Dylan"></div>
            </div>
            
            <h3>Timing attacks?</h3>

            <p><button class="btn btn-primary btn-sm" onclick="broadcastSimultaneousMessages()">Simultaneously send two messages giving all Bob's money to Alice and Charlie üòà</button></p>

            <div class="alert alert-danger" role="alert">This implementation can still be abuse!</div>


            <p>Few issues comes with what we just discribed here:</p>
            <p>First Alice have no way to know how many people in the network there is, so she have no way to know what
            <b>"50% of the users in the network"</b> is.</p>
            <p>Then, even if she had a way to know, Bob could create billions of fake users and swarm the network with
            puppets that will validate all his transactions. We need a better definition of: ‚Äúonce enough people
            have broadcast that message‚Äù for the currency to work.
            </p>

            <div class="row navigation">
                <div class="col-sm-12">
                    <a class="btn btn-success float-left" href="./crypto-currency-v2.html"><< prev</a>                    
                    <a class="btn btn-success float-right" href="./crypto-currency-v4.html">next >></a>
                </div>
            </div>
        </div>
    </body>
</html>
